<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Offline Football Predictor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <link rel="manifest" href="data:application/json;base64,ew0KICAic2hvcnRfbmFtZSI6ICJGb290YmFsbFByZWRpY3RvciIsDQogICJuYW1lIjogIk9mZmxpbmUgRm9vdGJhbGwgUHJlZGljdG9yIiwNCiAgImljb25zIjogWw0KICAgIHsNCiAgICAgICJzcmMiOiAiaWNvbnMvaWNvbi0xOTIucG5nIiwNCiAgICAgICJ0eXBlIjogImltYWdlL3BuZyIsDQogICAgICAic2l6ZXMiOiAiMTkyxDE5MiINCiAgICB9LA0KICAgIHsNCiAgICAgICJzcmMiOiAiaWNvbnMvaWNvbi01MTIucG5nIiwNCiAgICAgICJ0eXBlIjogImltYWdlL3BuZyIsDQogICAgICAic2l6ZXMiOiAiNTEyeDUxMiINCiAgICB9DQogIF0sDQogICJzdGFydF91cmwiOiAiLiIsDQogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLA0KICAidGhlbWVfY29loiOiAiIzAwMDAwMCIsDQogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiNmZmZmZmYiDQp9">

    <style>
        /* Simple loading spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: #09f;
            animation: spin 1s ease infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-100 font-sans antialiased text-gray-800">
    <div id="root" class="container mx-auto p-4 max-w-3xl">
        <header class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h1 class="text-3xl font-bold text-gray-900">Footy Predictor Pro 5000+ Turbo Edition</h1>
            <p class="text-gray-600 mt-1">Statistical machine-learned predictions with live fixture lookups, news analysis, and intelligent AI-powered prediction adjustment, via Gemini. Not to be used as a betting tool! - for sh*ts and gigs only!</p>
        </header>

        <main>
            <!-- Control Panel -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold mb-2">1. Load Historical Data</h2>
                <div class="flex flex-col sm:flex-row gap-4">
                    <div class="flex-grow">
                        <label for="league-select" class="block text-sm font-medium text-gray-700 mb-1">Select League:</label>
                        <select id="league-select" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500">
                            <option value="E0">English Premier League</option>
                            <option value="E1">English Championship</option>
                            <option value="E2">English League 1</option>
                            <option value="E3">English League 2</option>
                            <option value="SP1">Spanish La Liga</option>
                            <option value="D1">German Bundesliga</option>
                            <option value="D2">German Bundesliga 2</option>
                            <option value="I1">Italian Serie A</option>
                            <option value="F1">French Ligue 1</option>
                            <option value="N1">Dutch Eredivisie</option>
                        </select>
                    </div>
                    <button id="fetch-data-btn" class="self-end bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 flex items-center justify-center">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                        </svg>
                        Fetch & Store Data
                    </button>
                </div>
                <div id="status-area" class="mt-4 text-sm text-gray-600 h-5"></div>
            </div>

            <!-- Prediction Section -->
            <div class="bg-white rounded-lg shadow-md p-6">
                <h2 class="text-xl font-semibold mb-4">2. Find Fixtures & Generate Predictions</h2>
                <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <label for="api-key-input" class="block text-sm font-medium text-gray-700 mb-1">Enter your Gemini API Key:</label>
                    <input type="password" id="api-key-input" class="w-full p-2 border border-gray-300 rounded-md shadow-sm" placeholder="Your API key is stored locally">
                    <p class="text-xs text-gray-500 mt-1">Required to look up live fixtures. Get a key from Google AI Studio.</p>
                </div>
                <button id="find-fixtures-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition duration-300 flex items-center justify-center mb-4">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path d="M9 9a2 2 0 114 0 2 2 0 01-4 0z" /><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm0 2a10 10 0 100-20 10 10 0 000 20z" clip-rule="evenodd" /></svg>
                    Find Upcoming Fixtures with Gemini
                </button>
                 <div id="gemini-status-area" class="mt-4 text-sm text-gray-600 min-h-[20px]"></div>
                <div id="fixtures-container" class="mt-4">
                    <!-- Fixtures will be dynamically inserted here -->
                </div>
            </div>
        </main>

        <footer class="text-center text-xs text-gray-500 mt-8">
            <p>Data sourced from football-data.co.uk. Predictions are for entertainment purposes only.</p>
        </footer>
    </div>

    <script>
        // --- DOM Elements ---
        const leagueSelect = document.getElementById('league-select');
        const fetchDataBtn = document.getElementById('fetch-data-btn');
        const statusArea = document.getElementById('status-area');
        const fixturesContainer = document.getElementById('fixtures-container');
        const apiKeyInput = document.getElementById('api-key-input');
        const findFixturesBtn = document.getElementById('find-fixtures-btn');
        const geminiStatusArea = document.getElementById('gemini-status-area');
        
        // --- Constants ---
        const DB_NAME = 'FootballDataDB';
        const DB_VERSION = 1;
        const MATCHES_STORE_NAME = 'matches';
        const H2H_MATCHES_COUNT = 5;

        // --- Global State ---
        let db;
        let nnModel, lrModel; // Ensemble models
        let teamMap;
        let teamHistories;
        let trainingWorker;
        let isTraining = false;

        // --- PWA Service Worker ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                const swCode = `
                    const CACHE_NAME = 'football-predictor-v15';
                    const urlsToCache = ['/'];
                    self.addEventListener('install', event => { self.skipWaiting(); event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))); });
                    self.addEventListener('activate', event => { const cacheWhitelist = [CACHE_NAME]; event.waitUntil( caches.keys().then(cacheNames => Promise.all( cacheNames.map(cacheName => { if (cacheWhitelist.indexOf(cacheName) === -1) { return caches.delete(cacheName); } }) )).then(() => self.clients.claim()) ); });
                    self.addEventListener('fetch', event => { event.respondWith( caches.match(event.request).then(response => response || fetch(event.request)) ); });
                `;
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                navigator.serviceWorker.register(swUrl).then(reg => console.log('Service worker registered.', reg)).catch(err => console.log('Service worker registration failed:', err));
            });
        }
        
        // --- Web Worker ---
        function initWorker() {
            const workerCode = `
                importScripts('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js');

                const FORM_MATCHES_COUNT = 5;
                const H2H_MATCHES_COUNT = 5;

                self.onmessage = async (e) => {
                    const { type, payload } = e.data;
                    if (type === 'train_model') {
                        try {
                            self.postMessage({ type: 'status_update', payload: 'Preparing data for training...' });
                            const { features, labels, teamMap, histories } = prepareData(payload);
                            
                            if (!features || features.size === 0) { throw new Error("No valid training data could be generated."); }

                            const inputShape = features.shape[1];
                            const nnModel = createNnModel(inputShape);
                            const lrModel = createLrModel(inputShape);
                            
                            self.postMessage({ type: 'status_update', payload: 'Training Neural Network...' });
                            await nnModel.fit(features, labels, {
                                epochs: 50, batchSize: 32, validationSplit: 0.1, verbose: 0,
                                callbacks: { onEpochEnd: (epoch, logs) => self.postMessage({ type: 'status_update', payload: \`Training NN... Epoch \${epoch + 1}/50\` }) }
                            });

                            self.postMessage({ type: 'status_update', payload: 'Training Logistic Regression...' });
                            await lrModel.fit(features, labels, {
                                epochs: 50, batchSize: 32, validationSplit: 0.1, verbose: 0,
                                callbacks: { onEpochEnd: (epoch, logs) => self.postMessage({ type: 'status_update', payload: \`Training LR... Epoch \${epoch + 1}/50\` }) }
                            });

                            const [nnArtifacts, lrArtifacts] = await Promise.all([
                                nnModel.save(tf.io.withSaveHandler(async (artifacts) => artifacts)),
                                lrModel.save(tf.io.withSaveHandler(async (artifacts) => artifacts))
                            ]);

                            self.postMessage({ 
                                type: 'model_trained', 
                                payload: { 
                                    nnModelArtifacts: nnArtifacts, 
                                    lrModelArtifacts: lrArtifacts,
                                    teamMap: Array.from(teamMap.entries()), 
                                    teamHistories: Array.from(histories.entries()) 
                                }
                            });
                            tf.dispose([features, labels, nnModel, lrModel]);
                        } catch(error) { self.postMessage({ type: 'training_error', payload: error.message }); }

                    } else if (type === 'create_fixture_features') {
                        const { fixture, teamMap, teamHistories } = payload;
                        const reconstructedTeamMap = new Map(teamMap);
                        const reconstructedHistories = new Map(teamHistories.map(h => [h[0], h[1]]));
                        const result = createFeaturesForFixture(fixture, reconstructedTeamMap, reconstructedHistories);
                        e.ports[0].postMessage(result);
                    }
                };

                function parseDate(dateStr) {
                    if (!dateStr || dateStr.length < 8) return null;
                    if (dateStr.includes('-')) { const parts = dateStr.split('-'); if(parts.length !== 3) return null; const [year, month, day] = parts.map(p => parseInt(p, 10)); if(isNaN(year) || isNaN(month) || isNaN(day)) return null; return new Date(Date.UTC(year, month - 1, day)); } 
                    else if (dateStr.includes('/')) { const parts = dateStr.split('/'); if(parts.length !== 3) return null; const [day, month] = parts.map(p => parseInt(p, 10)); let year = parseInt(parts[2], 10); if(isNaN(day) || isNaN(month) || isNaN(year)) return null; if (year < 100) year += 2000; return new Date(Date.UTC(year, month - 1, day)); }
                    return null;
                }
                
                function calculateH2HStats(homeTeam, awayTeam, allMatchesUpToThisPoint) {
                    const h2hMatches = allMatchesUpToThisPoint.filter(m => (m.HomeTeam === homeTeam && m.AwayTeam === awayTeam) || (m.HomeTeam === awayTeam && m.AwayTeam === homeTeam) ).slice(-H2H_MATCHES_COUNT);
                    let homeTeamWins = 0, awayTeamWins = 0, draws = 0;
                    
                    h2hMatches.forEach(m => {
                        if (m.FTR === 'D') { draws++; }
                        else if ((m.FTR === 'H' && m.HomeTeam === homeTeam) || (m.FTR === 'A' && m.AwayTeam === homeTeam)) { homeTeamWins++; }
                        else { awayTeamWins++; }
                    });

                    const alpha = 1; const totalMatches = h2hMatches.length; const smoothedTotal = totalMatches + (alpha * 3);
                    const smoothedHomeWinRate = (homeTeamWins + alpha) / smoothedTotal;
                    const smoothedDrawRate = (draws + alpha) / smoothedTotal;
                    const smoothedAwayWinRate = (awayTeamWins + alpha) / smoothedTotal;

                    return { homeTeamWins, draws, awayTeamWins, totalMatches, featureHomeWin: smoothedHomeWinRate, featureDraw: smoothedDrawRate, featureAwayWin: smoothedAwayWinRate };
                }

                function calculateTeamStats(teamName, pastMatches, venue = 'Overall') {
                    let relevantMatches = pastMatches;
                    if (venue === 'Home') { relevantMatches = pastMatches.filter(m => m.HomeTeam === teamName); } 
                    else if (venue === 'Away') { relevantMatches = pastMatches.filter(m => m.AwayTeam === teamName); }

                    const lastNMatches = relevantMatches.slice(-FORM_MATCHES_COUNT);
                    if (lastNMatches.length === 0) return { gamesPlayed: 0, formPoints: 0, avgGoalsScored: 0, avgGoalsConceded: 0, avgSTF: 0, avgSTA: 0 };
                    
                    let formPoints = 0, goalsScored = 0, goalsConceded = 0, shotsOnTargetFor = 0, shotsOnTargetAgainst = 0;
                    for (const match of lastNMatches) {
                        const FTHG = parseInt(match.FTHG, 10); const FTAG = parseInt(match.FTAG, 10);
                        const HST = parseInt(match.HST, 10); const AST = parseInt(match.AST, 10);
                        if (isNaN(FTHG) || isNaN(FTAG) || isNaN(HST) || isNaN(AST)) continue;

                        if (match.HomeTeam === teamName) { 
                            goalsScored += FTHG; goalsConceded += FTAG; shotsOnTargetFor += HST; shotsOnTargetAgainst += AST;
                            if (match.FTR === 'H') formPoints += 3; if (match.FTR === 'D') formPoints += 1;
                        } else { 
                            goalsScored += FTAG; goalsConceded += FTHG; shotsOnTargetFor += AST; shotsOnTargetAgainst += HST;
                            if (match.FTR === 'A') formPoints += 3; if (match.FTR === 'D') formPoints += 1;
                        }
                    }
                    const numMatches = lastNMatches.length;
                    return { 
                        gamesPlayed: relevantMatches.length, 
                        formPoints: numMatches > 0 ? formPoints / (numMatches * 3) : 0, 
                        avgGoalsScored: numMatches > 0 ? goalsScored / numMatches : 0, 
                        avgGoalsConceded: numMatches > 0 ? goalsConceded / numMatches : 0,
                        avgSTF: numMatches > 0 ? shotsOnTargetFor / numMatches : 0,
                        avgSTA: numMatches > 0 ? shotsOnTargetAgainst / numMatches : 0
                    };
                }


                function prepareData(matches) {
                    matches = matches.map(m => ({ ...m, dateObj: parseDate(m.Date), id: m.HomeTeam + m.AwayTeam + m.Date })).filter(m => m.dateObj);
                    if (matches.length === 0) return {};
                    matches.sort((a, b) => a.dateObj - b.dateObj);

                    const oldestDate = matches[0].dateObj.getTime();
                    const newestDate = matches[matches.length - 1].dateObj.getTime();
                    const dateRange = newestDate - oldestDate;

                    const teams = [...new Set(matches.flatMap(m => [m.HomeTeam, m.AwayTeam]))].filter(Boolean);
                    const teamMap = new Map(teams.map((team, i) => [team, i]));
                    const numTeams = teams.length;

                    const histories = new Map(teams.map(team => [team, []]));
                    matches.forEach(m => {
                        if (m.HomeTeam && histories.has(m.HomeTeam)) histories.get(m.HomeTeam).push(m);
                        if (m.AwayTeam && histories.has(m.AwayTeam)) histories.get(m.AwayTeam).push(m);
                    });

                    const features = []; const labels = [];
                    for (let i = 0; i < matches.length; i++) {
                        const match = matches[i];
                        if (!match.HomeTeam || !match.AwayTeam || !match.FTR || !match.FTHG || !match.FTAG) continue;
                        
                        const homeTeamHistory = histories.get(match.HomeTeam).filter(m => m.dateObj < match.dateObj);
                        const awayTeamHistory = histories.get(match.AwayTeam).filter(m => m.dateObj < match.dateObj);

                        const homeStats = calculateTeamStats(match.HomeTeam, homeTeamHistory, 'Home');
                        const awayStats = calculateTeamStats(match.AwayTeam, awayTeamHistory, 'Away');
                        
                        if (homeStats.gamesPlayed < FORM_MATCHES_COUNT || awayStats.gamesPlayed < FORM_MATCHES_COUNT) continue;

                        const h2hStats = calculateH2HStats(match.HomeTeam, match.AwayTeam, matches.slice(0, i));

                        const homeTeamVec = Array(numTeams).fill(0); if (teamMap.has(match.HomeTeam)) homeTeamVec[teamMap.get(match.HomeTeam)] = 1;
                        const awayTeamVec = Array(numTeams).fill(0); if (teamMap.has(match.AwayTeam)) awayTeamVec[teamMap.get(match.AwayTeam)] = 1;
                        
                        const currentFeature = [ ...homeTeamVec, ...awayTeamVec, 
                            homeStats.formPoints, homeStats.avgGoalsScored, homeStats.avgGoalsConceded, homeStats.avgSTF, homeStats.avgSTA,
                            awayStats.formPoints, awayStats.avgGoalsScored, awayStats.avgGoalsConceded, awayStats.avgSTF, awayStats.avgSTA,
                            h2hStats.featureHomeWin, h2hStats.featureDraw, h2hStats.featureAwayWin 
                        ];
                        let currentLabel;
                        if (match.FTR === 'H') currentLabel = [1, 0, 0]; else if (match.FTR === 'D') currentLabel = [0, 1, 0]; else currentLabel = [0, 0, 1];
                        const recency = dateRange > 0 ? (match.dateObj.getTime() - oldestDate) / dateRange : 0.5;
                        const weight = 0.1 + 0.9 * recency;
                        const duplicationFactor = Math.max(1, Math.round(weight * 8));
                        for (let j = 0; j < duplicationFactor; j++) { features.push(currentFeature); labels.push(currentLabel); }
                    }
                    if (features.length === 0) return {};
                    return { features: tf.tensor2d(features), labels: tf.tensor2d(labels), teamMap: teamMap, histories: histories };
                }

                function createFeaturesForFixture(fixture, teamMap, histories) {
                    const numTeams = teamMap.size;
                    if (!histories.has(fixture.HomeTeam) || !histories.has(fixture.AwayTeam)) { return null; }
                    
                    const uniqueMatches = new Map();
                    [...histories.values()].flat().forEach(m => uniqueMatches.set(m.id, m));
                    const allHistoricalMatches = Array.from(uniqueMatches.values()).sort((a,b) => a.dateObj - b.dateObj);
                    
                    const homeTeamHistory = histories.get(fixture.HomeTeam) || [];
                    const awayTeamHistory = histories.get(fixture.AwayTeam) || [];
                    
                    const homeStats = calculateTeamStats(fixture.HomeTeam, homeTeamHistory, 'Home');
                    const awayStats = calculateTeamStats(fixture.AwayTeam, awayTeamHistory, 'Away');

                    const h2hStats = calculateH2HStats(fixture.HomeTeam, fixture.AwayTeam, allHistoricalMatches);

                    const homeTeamVec = Array(numTeams).fill(0); if (teamMap.has(fixture.HomeTeam)) homeTeamVec[teamMap.get(fixture.HomeTeam)] = 1;
                    const awayTeamVec = Array(numTeams).fill(0); if (teamMap.has(fixture.AwayTeam)) awayTeamVec[teamMap.get(fixture.AwayTeam)] = 1;
                    
                    const reasoningStats = { homeStats, awayStats, h2hStats };
                    const featureVector = [ ...homeTeamVec, ...awayTeamVec, 
                        homeStats.formPoints, homeStats.avgGoalsScored, homeStats.avgGoalsConceded, homeStats.avgSTF, homeStats.avgSTA,
                        awayStats.formPoints, awayStats.avgGoalsScored, awayStats.avgGoalsConceded, awayStats.avgSTF, awayStats.avgSTA,
                        h2hStats.featureHomeWin, h2hStats.featureDraw, h2hStats.featureAwayWin 
                    ];
                    return { featureVector, reasoningStats };
                }

                function createNnModel(inputShape) {
                    const model = tf.sequential();
                    // --- MODIFIED --- Added L2 regularization to combat overfitting
                    model.add(tf.layers.dense({ inputShape: [inputShape], units: 128, activation: 'relu', kernelRegularizer: tf.regularizers.l2({l2: 0.001}) }));
                    model.add(tf.layers.dropout({ rate: 0.5 }));
                    model.add(tf.layers.dense({ units: 64, activation: 'relu', kernelRegularizer: tf.regularizers.l2({l2: 0.001}) }));
                    model.add(tf.layers.dropout({ rate: 0.5 }));
                    model.add(tf.layers.dense({ units: 3 })); 
                    model.compile({ optimizer: tf.train.adam(0.001), loss: 'categoricalCrossentropy', lossReduction: 'sum' });
                    return model;
                }
                
                function createLrModel(inputShape) {
                    const model = tf.sequential();
                    model.add(tf.layers.dense({ inputShape: [inputShape], units: 3 }));
                    model.compile({ optimizer: tf.train.adam(0.001), loss: 'categoricalCrossentropy', lossReduction: 'sum' });
                    return model;
                }
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);
            trainingWorker = new Worker(workerUrl);
            
            trainingWorker.onmessage = (e) => {
                const { type, payload } = e.data;
                if (type === 'model_trained') {
                    isTraining = false;
                    Promise.all([
                        tf.loadLayersModel(tf.io.fromMemory(payload.nnModelArtifacts)),
                        tf.loadLayersModel(tf.io.fromMemory(payload.lrModelArtifacts))
                    ]).then(([deserializedNn, deserializedLr]) => {
                        nnModel = deserializedNn;
                        lrModel = deserializedLr;
                        teamMap = new Map(payload.teamMap);
                        teamHistories = new Map(payload.teamHistories.map(h => [h[0], h[1]]));
                        console.log('Ensemble models received from worker and loaded.');
                        document.querySelectorAll('.predict-btn-pending').forEach(btn => btn.click());
                    });
                } else if (type === 'status_update') {
                    const statusElements = document.querySelectorAll('.prediction-status-training');
                    statusElements.forEach(el => { el.innerHTML = `<span class="text-gray-500 italic">${payload}</span>`; });
                } else if (type === 'training_error') {
                    isTraining = false;
                    console.error("Training Worker Error:", payload);
                    const statusElements = document.querySelectorAll('.prediction-status-training');
                    statusElements.forEach(el => { el.innerHTML = `<span class="text-red-500">Training failed. Check console.</span>`; el.classList.remove('prediction-status-training'); });
                }
            };
        }

        // --- IndexedDB ---
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => { const db = event.target.result; if (!db.objectStoreNames.contains(MATCHES_STORE_NAME)) { db.createObjectStore(MATCHES_STORE_NAME, { keyPath: 'id', autoIncrement: true }); } };
                request.onsuccess = (event) => { db = event.target.result; resolve(db); };
                request.onerror = (event) => { console.error('Database error:', event.target.errorCode); reject(event.target.errorCode); };
            });
        }
        
        // --- Data Fetching & Processing ---
        function getSeasonCodes() {
            const NUMBER_OF_SEASONS = 6; const seasonCodes = []; const now = new Date(); const year = now.getFullYear(); const month = now.getMonth() + 1;
            let currentSeasonEndYear = month >= 8 ? year + 1 : year; const formatYear = (y) => y.toString().slice(-2);
            for (let i = 0; i < NUMBER_OF_SEASONS; i++) { const seasonEndYear = currentSeasonEndYear - i; const seasonStartYear = seasonEndYear - 1; seasonCodes.push(formatYear(seasonStartYear) + formatYear(seasonEndYear)); }
            return seasonCodes.reverse();
        }
        
        async function fetchAndStoreData() {
            setStatus('Fetching data...', true);
            const league = leagueSelect.value;
            const seasonCodes = getSeasonCodes();
            const proxy = 'https://corsproxy.io/?';
            let allMatches = []; let successfulFetches = 0;
            for (const season of seasonCodes) {
                const url = `${proxy}${encodeURIComponent(`https://www.football-data.co.uk/mmz4281/${season}/${league}.csv`)}`;
                try {
                    const response = await fetch(url);
                    if (response.ok) { const csvText = await response.text(); allMatches.push(...parseCSV(csvText)); successfulFetches++; }
                } catch (error) { console.error(`Error fetching data for season ${season}:`, error); }
            }
            if (successfulFetches === 0) { setStatus(`Failed to fetch any data.`, false); return; }
            nnModel = null; lrModel = null; teamHistories = null; teamMap = null; isTraining = false;
            await saveDataToDB(allMatches);
            setStatus(`Stored ${allMatches.length} matches from ${successfulFetches} seasons.`, false);
        }

        function parseCSV(text) {
            const lines = text.split('\n').filter(line => line.trim() !== ''); if (lines.length < 2) return [];
            const headers = lines[0].replace(/^\uFEFF/, '').split(',').map(h => h.trim());
            return lines.slice(1).map(line => { const values = line.split(','); const match = {}; headers.forEach((header, i) => { match[header] = values[i] ? values[i].trim() : ''; }); return match; });
        }

        function saveDataToDB(matches) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([MATCHES_STORE_NAME], 'readwrite');
                const store = transaction.objectStore(MATCHES_STORE_NAME);
                store.clear(); let counter = 0;
                matches.forEach(match => store.add({ ...match, id: counter++ }));
                transaction.oncomplete = () => { resolve(); };
                transaction.onerror = (event) => { console.error('Transaction error:', event.target.error); reject(event.target.error); };
            });
        }
        
        function getAllMatchesFromDB() {
             return new Promise((resolve, reject) => {
                const transaction = db.transaction([MATCHES_STORE_NAME], 'readonly');
                const store = transaction.objectStore(MATCHES_STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // --- UI Updates ---
        function setStatus(message, isLoading) {
            statusArea.innerHTML = isLoading ? `<div class="flex items-center"><div class="spinner mr-2"></div><p>${message}</p></div>` : `<p>${message}</p>`;
            fetchDataBtn.disabled = isLoading;
        }

        function setGeminiStatus(message, isLoading) {
            geminiStatusArea.innerHTML = isLoading ? `<div class="flex items-center"><div class="spinner mr-2"></div><p>${message}</p></div>` : `<p>${message}</p>`;
            findFixturesBtn.disabled = isLoading;
        }
        
        // --- Gemini API Integration ---
        async function findFixturesWithGemini() {
            const apiKey = apiKeyInput.value;
            if (!apiKey) { setGeminiStatus('<span class="text-red-500">Please enter your Gemini API key.</span>', false); return; }
            const selectedLeagueName = leagueSelect.options[leagueSelect.selectedIndex].text;
            setGeminiStatus('Searching for upcoming fixtures...', true);
            const prompt = `Using Google Search, find all upcoming league football fixtures for the '${selectedLeagueName}' scheduled within the next 7 days from today, ${new Date().toDateString()}. You MUST provide the response as a single, valid JSON array of objects. Do not include any explanatory text before or after the JSON array. Each object in the array must have these three keys: "HomeTeam", "AwayTeam", and "MatchDate" (formatted as "YYYY-MM-DD"). If your search finds no fixtures, you MUST return an empty JSON array: [].`;
            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }], tools: [{ "google_search": {} }] };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { throw new Error(`API Error: ${(await response.json()).error.message}`); }
                const result = await response.json();
                const textResponse = result.candidates[0].content.parts[0].text;
                const jsonString = textResponse.replace(/```json|```/g, '').trim();
                const fixtures = JSON.parse(jsonString);
                displayGeminiFixtures(fixtures);
                setGeminiStatus(`Found ${fixtures.length} upcoming fixtures from live search.`, false);
            } catch (error) {
                console.error('Gemini API Error:', error);
                setGeminiStatus(`<span class="text-red-500">Error finding fixtures. Check API key and console.</span>`, false);
                fixturesContainer.innerHTML = '';
            }
        }
        
        function displayGeminiFixtures(fixtures) {
            if (!fixtures || fixtures.length === 0) { fixturesContainer.innerHTML = '<p class="text-gray-500">No upcoming fixtures found in the next 7 days.</p>'; return; }
            let html = '<div class="space-y-4">';
            fixtures.sort((a, b) => new Date(a.MatchDate) - new Date(b.MatchDate));
            fixtures.forEach((fixture, index) => {
                const homeTeam = fixture.HomeTeam; const awayTeam = fixture.AwayTeam;
                const dateObj = new Date(fixture.MatchDate); dateObj.setUTCHours(12);
                const formattedDate = dateObj.toLocaleDateString(undefined, { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' });
                const homeTeamJs = homeTeam.replace(/'/g, "\\'"); const awayTeamJs = awayTeam.replace(/'/g, "\\'");
                html += `
                    <div class="p-4 bg-gray-50 rounded-lg space-y-3">
                        <div class="flex flex-col sm:flex-row items-center justify-between gap-4">
                            <div class="text-center sm:text-left"> <p class="font-bold text-lg">${homeTeam} vs ${awayTeam}</p> <p class="text-sm text-gray-500">${formattedDate}</p> </div>
                            <div class="flex items-center gap-2 flex-wrap justify-center">
                                <div id="prediction-${index}" class="text-sm font-semibold text-center w-full" data-prediction-values=""></div>
                                <button id="predict-btn-${index}" onclick="runPrediction('${homeTeamJs}', '${awayTeamJs}', ${index})" class="predict-btn bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-md text-sm">Predict</button>
                                <button id="refine-btn-${index}" onclick="refinePrediction('${homeTeamJs}', '${awayTeamJs}', ${index})" class="bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-3 rounded-md text-sm opacity-50 cursor-not-allowed" disabled>Refine with News</button>
                            </div>
                        </div>
                        <div id="reasoning-${index}" class="w-full pt-3 border-t border-gray-200 hidden"></div>
                        <div id="refined-section-${index}" class="hidden w-full pt-3 border-t border-gray-200"></div>
                    </div>
                `;
            });
            html += '</div>';
            fixturesContainer.innerHTML = html;
        }
        
        function findBestTeamNameMatch(name, teamMap) {
            const officialNames = Array.from(teamMap.keys()); const lowerName = name.toLowerCase();
            if (teamMap.has(name)) return name;
            for (const officialName of officialNames) { if (officialName.toLowerCase().includes(lowerName)) return officialName; }
            for (const officialName of officialNames) { if (lowerName.includes(officialName.toLowerCase())) return officialName; }
            let bestMatch = null; let maxScore = 0;
            const nameWords = new Set(lowerName.replace(/[^a-z0-9\s]/gi, '').split(' ').filter(w => w.length > 2));
            for (const officialName of officialNames) {
                let currentScore = 0;
                const officialWords = new Set(officialName.toLowerCase().replace(/[^a-z0-9\s]/gi, '').split(' ').filter(w => w.length > 2));
                for (const word of nameWords) { if (officialWords.has(word)) currentScore++; }
                if (currentScore > maxScore) { maxScore = currentScore; bestMatch = officialName; }
            }
            if (maxScore > 0) return bestMatch;
            console.warn(`Could not find a confident match for team name: "${name}"`);
            return name;
        }

        // --- Machine Learning ---
        async function runPrediction(homeTeam, awayTeam, index) {
            const predictionEl = document.getElementById(`prediction-${index}`);
            predictionEl.classList.remove('prediction-status-training');
            predictionEl.innerHTML = '<span class="text-gray-500">Processing...</span>';
            const refineBtn = document.getElementById(`refine-btn-${index}`);
            refineBtn.classList.add('opacity-50', 'cursor-not-allowed'); refineBtn.disabled = true;
            document.getElementById(`reasoning-${index}`).classList.add('hidden');

            if (nnModel && lrModel) {
                predictWithModel(homeTeam, awayTeam, index);
            } else {
                if(isTraining) { predictionEl.innerHTML = '<span class="text-gray-500 italic">Waiting for models to finish training...</span>'; } 
                else {
                    predictionEl.innerHTML = '<span class="text-gray-500 italic">Starting background training...</span>'; isTraining = true;
                    const historicalMatches = await getAllMatchesFromDB();
                    if (historicalMatches.length < 20) { predictionEl.innerHTML = '<span class="text-red-500">Not enough historical data.</span>'; isTraining = false; return; }
                    trainingWorker.postMessage({ type: 'train_model', payload: historicalMatches });
                }
                document.getElementById(`predict-btn-${index}`).classList.add('predict-btn-pending');
                predictionEl.classList.add('prediction-status-training');
            }
        }

        function displayStatisticalReasoning(index, homeTeam, awayTeam, stats) {
            const { homeStats, awayStats, h2hStats } = stats;
            const { homeTeamWins, draws, awayTeamWins, totalMatches } = h2hStats;
            const homeShort = homeTeam.substring(0, 10) + (homeTeam.length > 10 ? '...' : '');
            const awayShort = awayTeam.substring(0, 10) + (awayTeam.length > 10 ? '...' : '');
            const html = `
                <div class="space-y-2 text-xs text-gray-700">
                    <h4 class="font-semibold text-gray-800 text-sm">Statistical Snapshot</h4>
                    <div class="grid grid-cols-3 gap-2 text-center"> <div class="font-bold">Metric</div> <div class="font-bold">${homeShort} (Home)</div> <div class="font-bold">${awayShort} (Away)</div> </div>
                    <div class="grid grid-cols-3 gap-2 text-center bg-gray-100 p-1 rounded-md"> <div>Form (Pts/15)</div> <div>${Math.round(homeStats.formPoints * 15)}</div> <div>${Math.round(awayStats.formPoints * 15)}</div> </div>
                    <div class="grid grid-cols-3 gap-2 text-center bg-gray-100 p-1 rounded-md"> <div>Avg. Goals For</div> <div>${homeStats.avgGoalsScored.toFixed(2)}</div> <div>${awayStats.avgGoalsScored.toFixed(2)}</div> </div>
                    <div class="grid grid-cols-3 gap-2 text-center bg-gray-100 p-1 rounded-md"> <div>Avg. Goals Against</div> <div>${homeStats.avgGoalsConceded.toFixed(2)}</div> <div>${awayStats.avgGoalsConceded.toFixed(2)}</div> </div>
                    <div class="grid grid-cols-3 gap-2 text-center bg-gray-100 p-1 rounded-md"> <div>Avg. Shots Target For</div> <div>${homeStats.avgSTF.toFixed(2)}</div> <div>${awayStats.avgSTF.toFixed(2)}</div> </div>
                    <div class="grid grid-cols-3 gap-2 text-center bg-gray-100 p-1 rounded-md"> <div>Avg. Shots Target Against</div> <div>${homeStats.avgSTA.toFixed(2)}</div> <div>${awayStats.avgSTA.toFixed(2)}</div> </div>
                    <div class="grid grid-cols-1 gap-2 text-center bg-gray-100 p-1 rounded-md"> <div>H2H (Last ${totalMatches}): <b>${homeTeamWins}</b> (${homeShort}) - <b>${draws}</b> (Draw) - <b>${awayTeamWins}</b> (${awayShort})</div> </div>
                </div>
            `;
            const reasoningEl = document.getElementById(`reasoning-${index}`);
            reasoningEl.innerHTML = html;
            reasoningEl.classList.remove('hidden');
        }

        async function predictWithModel(homeTeam, awayTeam, index) {
            const predictionEl = document.getElementById(`prediction-${index}`);
            predictionEl.classList.remove('prediction-status-training');
            const refineBtn = document.getElementById(`refine-btn-${index}`);
            const officialHomeTeam = findBestTeamNameMatch(homeTeam, teamMap);
            const officialAwayTeam = findBestTeamNameMatch(awayTeam, teamMap);
            const workerRequest = { type: 'create_fixture_features', payload: { fixture: { HomeTeam: officialHomeTeam, AwayTeam: officialAwayTeam }, teamMap: Array.from(teamMap.entries()), teamHistories: Array.from(teamHistories.entries()) } };
            const result = await new Promise(resolve => { const channel = new MessageChannel(); trainingWorker.postMessage(workerRequest, [channel.port2]); channel.port1.onmessage = e => resolve(e.data); });

            if (!result || !result.featureVector) { predictionEl.innerHTML = '<span class="text-red-500">Could not generate features for teams.</span>'; return; }
            
            const { featureVector, reasoningStats } = result;
            displayStatisticalReasoning(index, officialHomeTeam, officialAwayTeam, reasoningStats);

            const fixtureFeatures = tf.tensor2d([featureVector]);
            const [nnLogitsTensor, lrLogitsTensor] = [nnModel.predict(fixtureFeatures), lrModel.predict(fixtureFeatures)];
            const averagedLogits = tf.add(nnLogitsTensor, lrLogitsTensor).div(tf.scalar(2));
            
            const temperature = 1.5;
            const getProbs = (logits) => tf.softmax(tf.div(logits, tf.scalar(temperature))).dataSync();
            
            const [nnH, nnD, nnA] = getProbs(nnLogitsTensor);
            const [lrH, lrD, lrA] = getProbs(lrLogitsTensor);
            const [ensH, ensD, ensA] = getProbs(averagedLogits);

            predictionEl.dataset.predictionValues = JSON.stringify([ensH, ensD, ensA]);
            predictionEl.innerHTML = `
                <div class="grid grid-cols-3 gap-1 text-center text-xs mb-2">
                    <div><span class="font-bold">NN:</span> ${Math.round(nnH*100)}|${Math.round(nnD*100)}|${Math.round(nnA*100)}%</div>
                    <div><span class="font-bold">LR:</span> ${Math.round(lrH*100)}|${Math.round(lrD*100)}|${Math.round(lrA*100)}%</div>
                    <div class="font-bold">Ens: ${Math.round(ensH*100)}|${Math.round(ensD*100)}|${Math.round(ensA*100)}%</div>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2.5 flex overflow-hidden border border-gray-300" title="Ensemble Prediction: H ${Math.round(ensH*100)}% | D ${Math.round(ensD*100)}% | A ${Math.round(ensA*100)}%">
                    <div class="bg-blue-500 h-full" style="width: ${ensH * 100}%"></div>
                    <div class="bg-gray-500 h-full" style="width: ${ensD * 100}%"></div>
                    <div class="bg-red-500 h-full" style="width: ${ensA * 100}%"></div>
                </div>
            `;
            
            refineBtn.classList.remove('opacity-50', 'cursor-not-allowed'); refineBtn.disabled = false;
            tf.dispose([fixtureFeatures, nnLogitsTensor, lrLogitsTensor, averagedLogits]);
            document.getElementById(`predict-btn-${index}`).classList.remove('predict-btn-pending');
        }
        
        async function refinePrediction(homeTeam, awayTeam, index) {
            const apiKey = apiKeyInput.value;
            if (!apiKey) { setGeminiStatus('<span class="text-red-500">Please enter your Gemini API key.</span>', false); return; }
            const refinedSection = document.getElementById(`refined-section-${index}`);
            refinedSection.innerHTML = '<div class="flex items-center text-sm text-gray-500"><div class="spinner mr-2"></div>Analyzing news, odds, and sentiment...</div>';
            refinedSection.classList.remove('hidden');
            const predictionEl = document.getElementById(`prediction-${index}`);
            const initialProbs = JSON.parse(predictionEl.dataset.predictionValues);
            if (!initialProbs) { refinedSection.innerHTML = '<p class="text-red-500">Please generate a base prediction first.</p>'; return; }

            const [p_h, p_d, p_a] = initialProbs;
            const confidence = Math.max(...initialProbs) - Math.min(...initialProbs);
            const dynamicAdjustmentFactor = 0.15 * (1 - confidence); 
            
            const statsString = `H: ${Math.round(p_h*100)}%, D: ${Math.round(p_d*100)}%, A: ${Math.round(p_a*100)}%`;
            const prompt = `For the upcoming football match ${homeTeam} vs ${awayTeam}, our statistical model provides a baseline prediction of: ${statsString}.
                Perform a Google Search for the latest team news, injuries, and betting odds.
                Provide a response as a single, valid JSON object with NO MARKDOWN. The object must have these exact keys:
                "newsSummary": (a concise summary of key news),
                "reasoning": (an array of 2-3 short strings explaining the key factors for sentiment),
                "odds": (an object with "homeWin", "draw", "awayWin" keys with decimal odds as strings, or "N/A"),
                "homeSentiment": (a float from -1.0 to 1.0 for the home team),
                "awaySentiment": (a float from -1.0 to 1.0 for the away team),
                "finalJustification": (a single sentence that reconciles the statistical prediction with the live news to explain the most likely final outcome).`;

            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                const payload = { contents: [{ parts: [{ text: prompt }] }], tools: [{ "google_search": {} }] };
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) { throw new Error(`API Error: ${(await response.json()).error.message}`); }
                const result = await response.json();
                const textResponse = result.candidates[0].content.parts[0].text;
                const jsonString = textResponse.replace(/```json|```/g, '').trim();
                const analysis = JSON.parse(jsonString);
                
                const net_sentiment = analysis.homeSentiment - analysis.awaySentiment;
                const adjustment = net_sentiment * dynamicAdjustmentFactor; 
                
                let new_p_h = p_h + adjustment; let new_p_a = p_a - adjustment; let new_p_d = p_d - Math.abs(adjustment) * 0.5;
                const clipped_p_h = Math.max(0.01, Math.min(0.99, new_p_h)); const clipped_p_a = Math.max(0.01, Math.min(0.99, new_p_a)); const clipped_p_d = Math.max(0.01, Math.min(0.99, new_p_d));
                const total = clipped_p_h + clipped_p_a + clipped_p_d;
                const final_p_h = clipped_p_h / total; const final_p_d = clipped_p_d / total; const final_p_a = clipped_p_a / total;
                
                let valueHtml = '';
                try {
                    const implied_h = analysis.odds.homeWin !== "N/A" && parseFloat(analysis.odds.homeWin) > 0 ? 1 / parseFloat(analysis.odds.homeWin) : null;
                    const implied_d = analysis.odds.draw !== "N/A" && parseFloat(analysis.odds.draw) > 0 ? 1 / parseFloat(analysis.odds.draw) : null;
                    const implied_a = analysis.odds.awayWin !== "N/A" && parseFloat(analysis.odds.awayWin) > 0 ? 1 / parseFloat(analysis.odds.awayWin) : null;

                    const value_h = implied_h ? final_p_h - implied_h : -Infinity;
                    const value_d = implied_d ? final_p_d - implied_d : -Infinity;
                    const value_a = implied_a ? final_p_a - implied_a : -Infinity;

                    const values = [
                        { outcome: 'Home Win', value: value_h, prob: final_p_h, implied: implied_h },
                        { outcome: 'Draw', value: value_d, prob: final_p_d, implied: implied_d },
                        { outcome: 'Away Win', value: value_a, prob: final_p_a, implied: implied_a }
                    ].filter(v => v.value > -Infinity);

                    if (values.length > 0) {
                        const bestValue = values.reduce((best, current) => current.value > best.value ? current : best, {value: -Infinity});
                        const valueThreshold = 0.05; // 5%

                        if (bestValue.value > valueThreshold) {
                            valueHtml = `<p>Best value identified in <b>${bestValue.outcome}</b> market.</p>
                                         <p class="text-xs">Our model's probability (${(bestValue.prob * 100).toFixed(1)}%) is <b>${(bestValue.value * 100).toFixed(1)}%</b> higher than implied odds (${(bestValue.implied * 100).toFixed(1)}%).</p>`;
                        } else {
                            valueHtml = '<p>No significant value detected (difference < 5%).</p>';
                        }
                    } else {
                        valueHtml = '<p>Could not perform value analysis due to missing odds data.</p>';
                    }
                } catch (e) {
                    console.error("Value analysis error:", e);
                    valueHtml = '<p>Error during value analysis.</p>';
                }

                refinedSection.innerHTML = `
                    <div class="space-y-4 text-sm">
                         <div> <h4 class="font-semibold text-gray-800">AI News Summary:</h4> <p class="text-gray-600 italic">${analysis.newsSummary}</p> </div>
                        <div> <h4 class="font-semibold text-gray-800">AI Reasoning:</h4> <ul class="list-disc list-inside space-y-1 text-gray-700"> ${analysis.reasoning.map(reason => `<li>${reason}</li>`).join('')} </ul> </div>
                        <div class="flex justify-between items-center bg-gray-100 p-2 rounded-md"> <span class="font-semibold text-gray-800">Latest Odds:</span> <span class="text-right"> H: <b class="text-blue-600">${analysis.odds.homeWin}</b>, D: <b class="text-gray-600">${analysis.odds.draw}</b>, A: <b class="text-red-600">${analysis.odds.awayWin}</b> </span> </div>
                        <div class="space-y-2 bg-gray-100 p-2 rounded-md">
                            <div class="flex justify-between items-center"> <span class="font-semibold text-gray-800">Ensemble Prediction:</span> <span class="font-bold text-right"> H: <b class="text-blue-600">${Math.round(p_h*100)}%</b>, D: <b class="text-gray-600">${Math.round(p_d*100)}%</b>, A: <b class="text-red-600">${Math.round(p_a*100)}%</b> </span> </div>
                            <div class="flex justify-between items-center"> <span class="font-semibold text-green-800">AI-Refined Prediction:</span> <span class="font-bold text-right"> H: <b class="text-blue-600">${Math.round(final_p_h*100)}%</b>, D: <b class="text-gray-600">${Math.round(final_p_d*100)}%</b>, A: <b class="text-red-600">${Math.round(final_p_a*100)}%</b> </span> </div>
                        </div>
                        <div class="bg-teal-100 border-l-4 border-teal-500 text-teal-700 p-3 rounded-md">
                            <h4 class="font-bold">Value Bet Analysis</h4>
                            ${valueHtml}
                        </div>
                         <div class="bg-indigo-100 border-l-4 border-indigo-500 text-indigo-700 p-3 rounded-md">
                            <h4 class="font-bold">Final Justification</h4>
                            <p class="italic">${analysis.finalJustification || "No justification provided."}</p>
                        </div>
                    </div>
                `;
            } catch(e) { console.error("Refinement Error:", e); refinedSection.innerHTML = '<p class="text-red-500">Could not retrieve or process AI analysis.</p>'; }
        }
        
        // --- Event Listeners & Initialization ---
        fetchDataBtn.addEventListener('click', fetchAndStoreData);
        findFixturesBtn.addEventListener('click', findFixturesWithGemini);
        
        window.addEventListener('DOMContentLoaded', async () => {
            await initDB();
            initWorker();
            setStatus('Ready. Select a league and fetch historical data.', false);
            apiKeyInput.value = localStorage.getItem('geminiApiKey') || '';
        });
        apiKeyInput.addEventListener('keyup', () => {
            localStorage.setItem('geminiApiKey', apiKeyInput.value);
        });
    </script>
</body>
</html>
